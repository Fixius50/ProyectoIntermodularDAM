"use strict";
/*
 * Copyright 2021-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer = exports.ResumableClientServerInputMultiplexerDemultiplexer = exports.ClientServerInputMultiplexerDemultiplexer = exports.StreamIdGenerator = void 0;
const _1 = require(".");
const Deferred_1 = require("./Deferred");
const Errors_1 = require("./Errors");
const Frames_1 = require("./Frames");
var StreamIdGenerator;
(function (StreamIdGenerator) {
    function create(seedId) {
        return new StreamIdGeneratorImpl(seedId);
    }
    StreamIdGenerator.create = create;
    class StreamIdGeneratorImpl {
        constructor(currentId) {
            this.currentId = currentId;
        }
        next(handler) {
            const nextId = this.currentId + 2;
            if (!handler(nextId)) {
                return;
            }
            this.currentId = nextId;
        }
    }
})(StreamIdGenerator = exports.StreamIdGenerator || (exports.StreamIdGenerator = {}));
class ClientServerInputMultiplexerDemultiplexer extends Deferred_1.Deferred {
    constructor(streamIdSupplier, outbound, closeable) {
        super();
        this.streamIdSupplier = streamIdSupplier;
        this.outbound = outbound;
        this.closeable = closeable;
        this.registry = {};
        closeable.onClose(this.close.bind(this));
    }
    handle(frame) {
        if (Frames_1.Frame.isConnection(frame)) {
            if (frame.type === _1.FrameTypes.RESERVED) {
                // TODO: throw
                return;
            }
            this.connectionFramesHandler.handle(frame);
            // TODO: Connection Handler
        }
        else if (Frames_1.Frame.isRequest(frame)) {
            if (this.registry[frame.streamId]) {
                // TODO: Send error and close connection
                return;
            }
            this.requestFramesHandler.handle(frame, this);
        }
        else {
            const handler = this.registry[frame.streamId];
            if (!handler) {
                // TODO: add validation
                return;
            }
            handler.handle(frame);
        }
        // TODO: add extensions support
    }
    connectionInbound(handler) {
        if (this.connectionFramesHandler) {
            throw new Error("Connection frame handler has already been installed");
        }
        this.connectionFramesHandler = handler;
    }
    handleRequestStream(handler) {
        if (this.requestFramesHandler) {
            throw new Error("Stream handler has already been installed");
        }
        this.requestFramesHandler = handler;
    }
    send(frame) {
        this.outbound.send(frame);
    }
    get connectionOutbound() {
        return this;
    }
    createRequestStream(streamHandler) {
        // handle requester side stream registration
        if (this.done) {
            streamHandler.handleReject(new Error("Already closed"));
            return;
        }
        const registry = this.registry;
        this.streamIdSupplier.next((streamId) => streamHandler.handleReady(streamId, this), Object.keys(registry));
    }
    connect(handler) {
        this.registry[handler.streamId] = handler;
    }
    disconnect(stream) {
        delete this.registry[stream.streamId];
    }
    close(error) {
        if (this.done) {
            super.close(error);
            return;
        }
        for (const streamId in this.registry) {
            const stream = this.registry[streamId];
            stream.close(new Error(`Closed. ${error ? `Original cause [${error}].` : ""}`));
        }
        super.close(error);
    }
}
exports.ClientServerInputMultiplexerDemultiplexer = ClientServerInputMultiplexerDemultiplexer;
class ResumableClientServerInputMultiplexerDemultiplexer extends ClientServerInputMultiplexerDemultiplexer {
    constructor(streamIdSupplier, outbound, closeable, frameStore, token, sessionStoreOrReconnector, sessionTimeout) {
        super(streamIdSupplier, outbound, new Deferred_1.Deferred());
        this.frameStore = frameStore;
        this.token = token;
        this.sessionTimeout = sessionTimeout;
        if (sessionStoreOrReconnector instanceof Function) {
            this.reconnector = sessionStoreOrReconnector;
        }
        else {
            this.sessionStore = sessionStoreOrReconnector;
        }
        closeable.onClose(this.handleConnectionClose.bind(this));
    }
    send(frame) {
        if (Frames_1.Frame.isConnection(frame)) {
            if (frame.type === _1.FrameTypes.KEEPALIVE) {
                frame.lastReceivedPosition = this.frameStore.lastReceivedFramePosition;
            }
            else if (frame.type === _1.FrameTypes.ERROR) {
                this.outbound.send(frame);
                if (this.sessionStore) {
                    delete this.sessionStore[this.token];
                }
                super.close(new Errors_1.RSocketError(frame.code, frame.message));
                return;
            }
        }
        else {
            this.frameStore.store(frame);
        }
        this.outbound.send(frame);
    }
    handle(frame) {
        if (Frames_1.Frame.isConnection(frame)) {
            if (frame.type === _1.FrameTypes.KEEPALIVE) {
                try {
                    this.frameStore.dropTo(frame.lastReceivedPosition);
                }
                catch (re) {
                    this.outbound.send({
                        type: _1.FrameTypes.ERROR,
                        streamId: 0,
                        flags: _1.Flags.NONE,
                        code: re.code,
                        message: re.message,
                    });
                    this.close(re);
                }
            }
            else if (frame.type === _1.FrameTypes.ERROR) {
                super.handle(frame);
                if (this.sessionStore) {
                    delete this.sessionStore[this.token];
                }
                super.close(new Errors_1.RSocketError(frame.code, frame.message));
                return;
            }
        }
        else {
            this.frameStore.record(frame);
        }
        super.handle(frame);
    }
    resume(frame, outbound, closeable) {
        this.outbound = outbound;
        switch (frame.type) {
            case _1.FrameTypes.RESUME: {
                clearTimeout(this.timeoutId);
                if (this.frameStore.lastReceivedFramePosition < frame.clientPosition) {
                    const e = new Errors_1.RSocketError(_1.ErrorCodes.REJECTED_RESUME, "Impossible to resume since first available client frame position is greater than last received server frame position");
                    this.outbound.send({
                        type: _1.FrameTypes.ERROR,
                        streamId: 0,
                        flags: _1.Flags.NONE,
                        code: e.code,
                        message: e.message,
                    });
                    this.close(e);
                    return;
                }
                try {
                    this.frameStore.dropTo(frame.serverPosition);
                }
                catch (re) {
                    this.outbound.send({
                        type: _1.FrameTypes.ERROR,
                        streamId: 0,
                        flags: _1.Flags.NONE,
                        code: re.code,
                        message: re.message,
                    });
                    this.close(re);
                    return;
                }
                this.outbound.send({
                    type: _1.FrameTypes.RESUME_OK,
                    streamId: 0,
                    flags: _1.Flags.NONE,
                    clientPosition: this.frameStore.lastReceivedFramePosition,
                });
                break;
            }
            case _1.FrameTypes.RESUME_OK: {
                try {
                    this.frameStore.dropTo(frame.clientPosition);
                }
                catch (re) {
                    this.outbound.send({
                        type: _1.FrameTypes.ERROR,
                        streamId: 0,
                        flags: _1.Flags.NONE,
                        code: re.code,
                        message: re.message,
                    });
                    this.close(re);
                }
                break;
            }
        }
        this.frameStore.drain(this.outbound.send.bind(this.outbound));
        closeable.onClose(this.handleConnectionClose.bind(this));
        this.connectionFramesHandler.resume();
    }
    handleConnectionClose(_error) {
        return __awaiter(this, void 0, void 0, function* () {
            this.connectionFramesHandler.pause();
            if (this.reconnector) {
                try {
                    yield this.reconnector(this, this.frameStore);
                }
                catch (e) {
                    this.close(e);
                }
            }
            else {
                this.timeoutId = setTimeout(this.close.bind(this), this.sessionTimeout);
            }
        });
    }
}
exports.ResumableClientServerInputMultiplexerDemultiplexer = ResumableClientServerInputMultiplexerDemultiplexer;
class ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer {
    constructor(outbound, closeable, delegate) {
        this.outbound = outbound;
        this.closeable = closeable;
        this.delegate = delegate;
        this.resumed = false;
    }
    close() {
        this.delegate.close();
    }
    onClose(callback) {
        this.delegate.onClose(callback);
    }
    get connectionOutbound() {
        return this.delegate.connectionOutbound;
    }
    createRequestStream(streamHandler) {
        this.delegate.createRequestStream(streamHandler);
    }
    connectionInbound(handler) {
        this.delegate.connectionInbound(handler);
    }
    handleRequestStream(handler) {
        this.delegate.handleRequestStream(handler);
    }
    handle(frame) {
        if (!this.resumed) {
            if (frame.type === _1.FrameTypes.RESUME_OK) {
                this.resumed = true;
                this.delegate.resume(frame, this.outbound, this.closeable);
                return;
            }
            else {
                this.outbound.send({
                    type: _1.FrameTypes.ERROR,
                    streamId: 0,
                    code: _1.ErrorCodes.CONNECTION_ERROR,
                    message: `Incomplete RESUME handshake. Unexpected frame ${frame.type} received`,
                    flags: _1.Flags.NONE,
                });
                this.closeable.close();
                this.closeable.onClose(() => this.delegate.close(new Errors_1.RSocketError(_1.ErrorCodes.CONNECTION_ERROR, `Incomplete RESUME handshake. Unexpected frame ${frame.type} received`)));
            }
            return;
        }
        this.delegate.handle(frame);
    }
}
exports.ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer = ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer;
//# sourceMappingURL=ClientServerMultiplexerDemultiplexer.js.map