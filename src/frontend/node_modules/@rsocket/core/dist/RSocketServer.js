"use strict";
/*
 * Copyright 2021-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RSocketServer = void 0;
const ClientServerMultiplexerDemultiplexer_1 = require("./ClientServerMultiplexerDemultiplexer");
const Errors_1 = require("./Errors");
const Frames_1 = require("./Frames");
const RSocketSupport_1 = require("./RSocketSupport");
const Resume_1 = require("./Resume");
class RSocketServer {
    constructor(config) {
        var _a, _b;
        this.acceptor = config.acceptor;
        this.transport = config.transport;
        this.lease = config.lease;
        this.serverSideKeepAlive = config.serverSideKeepAlive;
        this.sessionStore = config.resume ? {} : undefined;
        this.sessionTimeout = (_b = (_a = config.resume) === null || _a === void 0 ? void 0 : _a.sessionTimeout) !== null && _b !== void 0 ? _b : undefined;
    }
    bind() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.transport.bind((frame, connection) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d;
                switch (frame.type) {
                    case Frames_1.FrameTypes.SETUP: {
                        try {
                            if (this.lease && !Frames_1.Flags.hasLease(frame.flags)) {
                                const error = new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED_SETUP, "Lease has to be enabled");
                                connection.multiplexerDemultiplexer.connectionOutbound.send({
                                    type: Frames_1.FrameTypes.ERROR,
                                    streamId: 0,
                                    flags: Frames_1.Flags.NONE,
                                    code: error.code,
                                    message: error.message,
                                });
                                connection.close(error);
                                return;
                            }
                            if (Frames_1.Flags.hasLease(frame.flags) && !this.lease) {
                                const error = new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED_SETUP, "Lease has to be disabled");
                                connection.multiplexerDemultiplexer.connectionOutbound.send({
                                    type: Frames_1.FrameTypes.ERROR,
                                    streamId: 0,
                                    flags: Frames_1.Flags.NONE,
                                    code: error.code,
                                    message: error.message,
                                });
                                connection.close(error);
                                return;
                            }
                            const leaseHandler = Frames_1.Flags.hasLease(frame.flags)
                                ? new RSocketSupport_1.LeaseHandler((_a = this.lease.maxPendingRequests) !== null && _a !== void 0 ? _a : 256, connection.multiplexerDemultiplexer)
                                : undefined;
                            const requester = new RSocketSupport_1.RSocketRequester(connection, (_c = (_b = this.fragmentation) === null || _b === void 0 ? void 0 : _b.maxOutboundFragmentSize) !== null && _c !== void 0 ? _c : 0, leaseHandler);
                            const responder = yield this.acceptor.accept({
                                data: frame.data,
                                dataMimeType: frame.dataMimeType,
                                metadata: frame.metadata,
                                metadataMimeType: frame.metadataMimeType,
                                flags: frame.flags,
                                keepAliveMaxLifetime: frame.lifetime,
                                keepAliveInterval: frame.keepAlive,
                                resumeToken: frame.resumeToken,
                            }, requester);
                            const keepAliveHandler = new RSocketSupport_1.KeepAliveHandler(connection, frame.lifetime);
                            const keepAliveSender = this.serverSideKeepAlive
                                ? new RSocketSupport_1.KeepAliveSender(connection.multiplexerDemultiplexer.connectionOutbound, frame.keepAlive)
                                : undefined;
                            const connectionFrameHandler = new RSocketSupport_1.DefaultConnectionFrameHandler(connection, keepAliveHandler, keepAliveSender, leaseHandler, responder);
                            const streamsHandler = new RSocketSupport_1.DefaultStreamRequestHandler(responder, 0);
                            connection.onClose((e) => {
                                keepAliveSender === null || keepAliveSender === void 0 ? void 0 : keepAliveSender.close();
                                keepAliveHandler.close();
                                connectionFrameHandler.close(e);
                            });
                            connection.multiplexerDemultiplexer.connectionInbound(connectionFrameHandler);
                            connection.multiplexerDemultiplexer.handleRequestStream(streamsHandler);
                            keepAliveHandler.start();
                            keepAliveSender === null || keepAliveSender === void 0 ? void 0 : keepAliveSender.start();
                        }
                        catch (e) {
                            connection.multiplexerDemultiplexer.connectionOutbound.send({
                                type: Frames_1.FrameTypes.ERROR,
                                streamId: 0,
                                code: Errors_1.ErrorCodes.REJECTED_SETUP,
                                message: (_d = e.message) !== null && _d !== void 0 ? _d : "",
                                flags: Frames_1.Flags.NONE,
                            });
                            connection.close(e instanceof Errors_1.RSocketError
                                ? e
                                : new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED_SETUP, e.message));
                        }
                        return;
                    }
                    case Frames_1.FrameTypes.RESUME: {
                        // frame should be handled earlier
                        return;
                    }
                    default: {
                        connection.multiplexerDemultiplexer.connectionOutbound.send({
                            type: Frames_1.FrameTypes.ERROR,
                            streamId: 0,
                            code: Errors_1.ErrorCodes.UNSUPPORTED_SETUP,
                            message: "Unsupported setup",
                            flags: Frames_1.Flags.NONE,
                        });
                        connection.close(new Errors_1.RSocketError(Errors_1.ErrorCodes.UNSUPPORTED_SETUP));
                    }
                }
            }), (frame, outbound) => {
                if (frame.type === Frames_1.FrameTypes.RESUME) {
                    if (this.sessionStore) {
                        const multiplexerDemultiplexer = this.sessionStore[frame.resumeToken.toString()];
                        if (!multiplexerDemultiplexer) {
                            outbound.send({
                                type: Frames_1.FrameTypes.ERROR,
                                streamId: 0,
                                code: Errors_1.ErrorCodes.REJECTED_RESUME,
                                message: "No session found for the given resume token",
                                flags: Frames_1.Flags.NONE,
                            });
                            outbound.close();
                            return;
                        }
                        multiplexerDemultiplexer.resume(frame, outbound, outbound);
                        return multiplexerDemultiplexer;
                    }
                    outbound.send({
                        type: Frames_1.FrameTypes.ERROR,
                        streamId: 0,
                        code: Errors_1.ErrorCodes.REJECTED_RESUME,
                        message: "Resume is not enabled",
                        flags: Frames_1.Flags.NONE,
                    });
                    outbound.close();
                    return;
                }
                else if (frame.type === Frames_1.FrameTypes.SETUP) {
                    if (Frames_1.Flags.hasResume(frame.flags)) {
                        if (!this.sessionStore) {
                            const error = new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED_SETUP, "No resume support");
                            outbound.send({
                                type: Frames_1.FrameTypes.ERROR,
                                streamId: 0,
                                flags: Frames_1.Flags.NONE,
                                code: error.code,
                                message: error.message,
                            });
                            outbound.close(error);
                            return;
                        }
                        const multiplexerDumiltiplexer = new ClientServerMultiplexerDemultiplexer_1.ResumableClientServerInputMultiplexerDemultiplexer(ClientServerMultiplexerDemultiplexer_1.StreamIdGenerator.create(0), outbound, outbound, new Resume_1.FrameStore(), // TODO: add size parameter
                        frame.resumeToken.toString(), this.sessionStore, this.sessionTimeout);
                        this.sessionStore[frame.resumeToken.toString()] =
                            multiplexerDumiltiplexer;
                        return multiplexerDumiltiplexer;
                    }
                }
                return new ClientServerMultiplexerDemultiplexer_1.ClientServerInputMultiplexerDemultiplexer(ClientServerMultiplexerDemultiplexer_1.StreamIdGenerator.create(0), outbound, outbound);
            });
        });
    }
}
exports.RSocketServer = RSocketServer;
//# sourceMappingURL=RSocketServer.js.map