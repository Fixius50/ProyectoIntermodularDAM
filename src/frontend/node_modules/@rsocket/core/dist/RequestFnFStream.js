"use strict";
/*
 * Copyright 2021-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestFnfResponderStream = exports.RequestFnFRequesterStream = void 0;
const Errors_1 = require("./Errors");
const Fragmenter_1 = require("./Fragmenter");
const Frames_1 = require("./Frames");
const Reassembler = __importStar(require("./Reassembler"));
class RequestFnFRequesterStream {
    constructor(payload, receiver, fragmentSize, leaseManager) {
        this.payload = payload;
        this.receiver = receiver;
        this.fragmentSize = fragmentSize;
        this.leaseManager = leaseManager;
        this.streamType = Frames_1.FrameTypes.REQUEST_FNF;
    }
    handleReady(streamId, stream) {
        if (this.done) {
            return false;
        }
        this.streamId = streamId;
        if ((0, Fragmenter_1.isFragmentable)(this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_FNF)) {
            for (const frame of (0, Fragmenter_1.fragment)(streamId, this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_FNF)) {
                stream.send(frame);
            }
        }
        else {
            stream.send({
                type: Frames_1.FrameTypes.REQUEST_FNF,
                data: this.payload.data,
                metadata: this.payload.metadata,
                flags: this.payload.metadata ? Frames_1.Flags.METADATA : 0,
                streamId,
            });
        }
        this.done = true;
        this.receiver.onComplete();
        return true;
    }
    handleReject(error) {
        if (this.done) {
            return;
        }
        this.done = true;
        this.receiver.onError(error);
    }
    cancel() {
        var _a;
        if (this.done) {
            return;
        }
        this.done = true;
        (_a = this.leaseManager) === null || _a === void 0 ? void 0 : _a.cancelRequest(this);
    }
    handle(frame) {
        if (frame.type == Frames_1.FrameTypes.ERROR) {
            this.close(new Errors_1.RSocketError(frame.code, frame.message));
            return;
        }
        this.close(new Errors_1.RSocketError(Errors_1.ErrorCodes.CANCELED, "Received invalid frame"));
    }
    close(error) {
        if (this.done) {
            console.warn(`Trying to close for the second time. ${error ? `Dropping error [${error}].` : ""}`);
            return;
        }
        if (error) {
            this.receiver.onError(error);
        }
        else {
            this.receiver.onComplete();
        }
    }
}
exports.RequestFnFRequesterStream = RequestFnFRequesterStream;
class RequestFnfResponderStream {
    constructor(streamId, stream, handler, frame) {
        this.streamId = streamId;
        this.stream = stream;
        this.handler = handler;
        this.streamType = Frames_1.FrameTypes.REQUEST_FNF;
        if (Frames_1.Flags.hasFollows(frame.flags)) {
            Reassembler.add(this, frame.data, frame.metadata);
            stream.connect(this);
            return;
        }
        const payload = {
            data: frame.data,
            metadata: frame.metadata,
        };
        try {
            this.cancellable = handler(payload, this);
        }
        catch (e) {
            // do nothing
        }
    }
    handle(frame) {
        let errorMessage;
        if (frame.type == Frames_1.FrameTypes.PAYLOAD) {
            if (Frames_1.Flags.hasFollows(frame.flags)) {
                if (Reassembler.add(this, frame.data, frame.metadata)) {
                    return;
                }
                errorMessage = "Unexpected fragment size";
            }
            else {
                this.stream.disconnect(this);
                const payload = Reassembler.reassemble(this, frame.data, frame.metadata);
                try {
                    this.cancellable = this.handler(payload, this);
                }
                catch (e) {
                    // do nothing
                }
                return;
            }
        }
        else {
            errorMessage = `Unexpected frame type [${frame.type}]`;
        }
        this.done = true;
        if (frame.type != Frames_1.FrameTypes.CANCEL && frame.type != Frames_1.FrameTypes.ERROR) {
            this.stream.send({
                type: Frames_1.FrameTypes.ERROR,
                streamId: this.streamId,
                flags: Frames_1.Flags.NONE,
                code: Errors_1.ErrorCodes.CANCELED,
                message: errorMessage,
            });
        }
        this.stream.disconnect(this);
        Reassembler.cancel(this);
        // TODO: throws if strict
    }
    close(error) {
        var _a;
        if (this.done) {
            console.warn(`Trying to close for the second time. ${error ? `Dropping error [${error}].` : ""}`);
            return;
        }
        this.done = true;
        Reassembler.cancel(this);
        (_a = this.cancellable) === null || _a === void 0 ? void 0 : _a.cancel();
    }
    onError(error) { }
    onComplete() { }
}
exports.RequestFnfResponderStream = RequestFnfResponderStream;
/*
export function request(
  payload: Payload,
  responderStream: UnidirectionalStream
): Handler<Cancellable> {
  return {
    create: (r) => {
      const response = new RequestFnFRequesterHandler(
        payload,
        responderStream,
        r
      );

      r.add(response);

      return response;
    },
  };
}

export function response(
  handler: (payload: Payload, responderStream: UnidirectionalStream,) => void
): Handler<void> {
  return {
    create: (r) => new RequestFnfResponderHandler(),
  };
} */
//# sourceMappingURL=RequestFnFStream.js.map