"use strict";
/*
 * Copyright 2021-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.fragmentWithRequestN = exports.fragment = exports.isFragmentable = void 0;
const Frames_1 = require("./Frames");
function isFragmentable(payload, fragmentSize, frameType) {
    if (fragmentSize === 0) {
        return false;
    }
    return (payload.data.byteLength +
        (payload.metadata ? payload.metadata.byteLength + Frames_1.Lengths.METADATA : 0) +
        (frameType == Frames_1.FrameTypes.REQUEST_STREAM ||
            frameType == Frames_1.FrameTypes.REQUEST_CHANNEL
            ? Frames_1.Lengths.REQUEST
            : 0) >
        fragmentSize);
}
exports.isFragmentable = isFragmentable;
function* fragment(streamId, payload, fragmentSize, frameType, isComplete = false) {
    var _a, _b;
    const dataLength = (_b = (_a = payload.data) === null || _a === void 0 ? void 0 : _a.byteLength) !== null && _b !== void 0 ? _b : 0;
    let firstFrame = frameType !== Frames_1.FrameTypes.PAYLOAD;
    let remaining = fragmentSize;
    let metadata;
    if (payload.metadata) {
        const metadataLength = payload.metadata.byteLength;
        if (metadataLength === 0) {
            remaining -= Frames_1.Lengths.METADATA;
            metadata = Buffer.allocUnsafe(0);
        }
        else {
            let metadataPosition = 0;
            if (firstFrame) {
                remaining -= Frames_1.Lengths.METADATA;
                const nextMetadataPosition = Math.min(metadataLength, metadataPosition + remaining);
                metadata = payload.metadata.slice(metadataPosition, nextMetadataPosition);
                remaining -= metadata.byteLength;
                metadataPosition = nextMetadataPosition;
                if (remaining === 0) {
                    firstFrame = false;
                    yield {
                        type: frameType,
                        flags: Frames_1.Flags.FOLLOWS | Frames_1.Flags.METADATA,
                        data: undefined,
                        metadata,
                        streamId,
                    };
                    metadata = undefined;
                    remaining = fragmentSize;
                }
            }
            while (metadataPosition < metadataLength) {
                remaining -= Frames_1.Lengths.METADATA;
                const nextMetadataPosition = Math.min(metadataLength, metadataPosition + remaining);
                metadata = payload.metadata.slice(metadataPosition, nextMetadataPosition);
                remaining -= metadata.byteLength;
                metadataPosition = nextMetadataPosition;
                if (remaining === 0 || dataLength === 0) {
                    yield {
                        type: Frames_1.FrameTypes.PAYLOAD,
                        flags: Frames_1.Flags.NEXT |
                            Frames_1.Flags.METADATA |
                            (metadataPosition === metadataLength &&
                                isComplete &&
                                dataLength === 0
                                ? Frames_1.Flags.COMPLETE
                                : Frames_1.Flags.FOLLOWS),
                        data: undefined,
                        metadata,
                        streamId,
                    };
                    metadata = undefined;
                    remaining = fragmentSize;
                }
            }
        }
    }
    let dataPosition = 0;
    let data;
    if (firstFrame) {
        const nextDataPosition = Math.min(dataLength, dataPosition + remaining);
        data = payload.data.slice(dataPosition, nextDataPosition);
        remaining -= data.byteLength;
        dataPosition = nextDataPosition;
        yield {
            type: frameType,
            flags: Frames_1.Flags.FOLLOWS | (metadata ? Frames_1.Flags.METADATA : Frames_1.Flags.NONE),
            data,
            metadata,
            streamId,
        };
        metadata = undefined;
        data = undefined;
        remaining = fragmentSize;
    }
    while (dataPosition < dataLength) {
        const nextDataPosition = Math.min(dataLength, dataPosition + remaining);
        data = payload.data.slice(dataPosition, nextDataPosition);
        remaining -= data.byteLength;
        dataPosition = nextDataPosition;
        yield {
            type: Frames_1.FrameTypes.PAYLOAD,
            flags: dataPosition === dataLength
                ? (isComplete ? Frames_1.Flags.COMPLETE : Frames_1.Flags.NONE) |
                    Frames_1.Flags.NEXT |
                    (metadata ? Frames_1.Flags.METADATA : 0)
                : Frames_1.Flags.FOLLOWS | Frames_1.Flags.NEXT | (metadata ? Frames_1.Flags.METADATA : 0),
            data,
            metadata,
            streamId,
        };
        metadata = undefined;
        data = undefined;
        remaining = fragmentSize;
    }
}
exports.fragment = fragment;
function* fragmentWithRequestN(streamId, payload, fragmentSize, frameType, requestN, isComplete = false) {
    var _a, _b;
    const dataLength = (_b = (_a = payload.data) === null || _a === void 0 ? void 0 : _a.byteLength) !== null && _b !== void 0 ? _b : 0;
    let firstFrame = true;
    let remaining = fragmentSize;
    let metadata;
    if (payload.metadata) {
        const metadataLength = payload.metadata.byteLength;
        if (metadataLength === 0) {
            remaining -= Frames_1.Lengths.METADATA;
            metadata = Buffer.allocUnsafe(0);
        }
        else {
            let metadataPosition = 0;
            if (firstFrame) {
                remaining -= Frames_1.Lengths.METADATA + Frames_1.Lengths.REQUEST;
                const nextMetadataPosition = Math.min(metadataLength, metadataPosition + remaining);
                metadata = payload.metadata.slice(metadataPosition, nextMetadataPosition);
                remaining -= metadata.byteLength;
                metadataPosition = nextMetadataPosition;
                if (remaining === 0) {
                    firstFrame = false;
                    yield {
                        type: frameType,
                        flags: Frames_1.Flags.FOLLOWS | Frames_1.Flags.METADATA,
                        data: undefined,
                        requestN,
                        metadata,
                        streamId,
                    };
                    metadata = undefined;
                    remaining = fragmentSize;
                }
            }
            while (metadataPosition < metadataLength) {
                remaining -= Frames_1.Lengths.METADATA;
                const nextMetadataPosition = Math.min(metadataLength, metadataPosition + remaining);
                metadata = payload.metadata.slice(metadataPosition, nextMetadataPosition);
                remaining -= metadata.byteLength;
                metadataPosition = nextMetadataPosition;
                if (remaining === 0 || dataLength === 0) {
                    yield {
                        type: Frames_1.FrameTypes.PAYLOAD,
                        flags: Frames_1.Flags.NEXT |
                            Frames_1.Flags.METADATA |
                            (metadataPosition === metadataLength &&
                                isComplete &&
                                dataLength === 0
                                ? Frames_1.Flags.COMPLETE
                                : Frames_1.Flags.FOLLOWS),
                        data: undefined,
                        metadata,
                        streamId,
                    };
                    metadata = undefined;
                    remaining = fragmentSize;
                }
            }
        }
    }
    let dataPosition = 0;
    let data;
    if (firstFrame) {
        remaining -= Frames_1.Lengths.REQUEST;
        const nextDataPosition = Math.min(dataLength, dataPosition + remaining);
        data = payload.data.slice(dataPosition, nextDataPosition);
        remaining -= data.byteLength;
        dataPosition = nextDataPosition;
        yield {
            type: frameType,
            flags: Frames_1.Flags.FOLLOWS | (metadata ? Frames_1.Flags.METADATA : Frames_1.Flags.NONE),
            data,
            requestN,
            metadata,
            streamId,
        };
        metadata = undefined;
        data = undefined;
        remaining = fragmentSize;
    }
    while (dataPosition < dataLength) {
        const nextDataPosition = Math.min(dataLength, dataPosition + remaining);
        data = payload.data.slice(dataPosition, nextDataPosition);
        remaining -= data.byteLength;
        dataPosition = nextDataPosition;
        yield {
            type: Frames_1.FrameTypes.PAYLOAD,
            flags: dataPosition === dataLength
                ? (isComplete ? Frames_1.Flags.COMPLETE : Frames_1.Flags.NONE) |
                    Frames_1.Flags.NEXT |
                    (metadata ? Frames_1.Flags.METADATA : 0)
                : Frames_1.Flags.FOLLOWS | Frames_1.Flags.NEXT | (metadata ? Frames_1.Flags.METADATA : 0),
            data,
            metadata,
            streamId,
        };
        metadata = undefined;
        data = undefined;
        remaining = fragmentSize;
    }
}
exports.fragmentWithRequestN = fragmentWithRequestN;
//# sourceMappingURL=Fragmenter.js.map