"use strict";
/*
 * Copyright 2021-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeepAliveSender = exports.KeepAliveHandler = exports.DefaultConnectionFrameHandler = exports.DefaultStreamRequestHandler = exports.LeaseHandler = exports.RSocketRequester = void 0;
const Errors_1 = require("./Errors");
const Frames_1 = require("./Frames");
const RequestChannelStream_1 = require("./RequestChannelStream");
const RequestFnFStream_1 = require("./RequestFnFStream");
const RequestResponseStream_1 = require("./RequestResponseStream");
const RequestStreamStream_1 = require("./RequestStreamStream");
class RSocketRequester {
    constructor(connection, fragmentSize, leaseManager) {
        this.connection = connection;
        this.fragmentSize = fragmentSize;
        this.leaseManager = leaseManager;
    }
    fireAndForget(payload, responderStream) {
        const handler = new RequestFnFStream_1.RequestFnFRequesterStream(payload, responderStream, this.fragmentSize, this.leaseManager);
        if (this.leaseManager) {
            this.leaseManager.requestLease(handler);
        }
        else {
            this.connection.multiplexerDemultiplexer.createRequestStream(handler);
        }
        return handler;
    }
    requestResponse(payload, responderStream) {
        const handler = new RequestResponseStream_1.RequestResponseRequesterStream(payload, responderStream, this.fragmentSize, this.leaseManager);
        if (this.leaseManager) {
            this.leaseManager.requestLease(handler);
        }
        else {
            this.connection.multiplexerDemultiplexer.createRequestStream(handler);
        }
        return handler;
    }
    requestStream(payload, initialRequestN, responderStream) {
        const handler = new RequestStreamStream_1.RequestStreamRequesterStream(payload, responderStream, this.fragmentSize, initialRequestN, this.leaseManager);
        if (this.leaseManager) {
            this.leaseManager.requestLease(handler);
        }
        else {
            this.connection.multiplexerDemultiplexer.createRequestStream(handler);
        }
        return handler;
    }
    requestChannel(payload, initialRequestN, isCompleted, responderStream) {
        const handler = new RequestChannelStream_1.RequestChannelRequesterStream(payload, isCompleted, responderStream, this.fragmentSize, initialRequestN, this.leaseManager);
        if (this.leaseManager) {
            this.leaseManager.requestLease(handler);
        }
        else {
            this.connection.multiplexerDemultiplexer.createRequestStream(handler);
        }
        return handler;
    }
    metadataPush(metadata, responderStream) {
        throw new Error("Method not implemented.");
    }
    close(error) {
        this.connection.close(error);
    }
    onClose(callback) {
        this.connection.onClose(callback);
    }
}
exports.RSocketRequester = RSocketRequester;
class LeaseHandler {
    constructor(maxPendingRequests, multiplexer) {
        this.maxPendingRequests = maxPendingRequests;
        this.multiplexer = multiplexer;
        this.pendingRequests = [];
        this.expirationTime = 0;
        this.availableLease = 0;
    }
    handle(frame) {
        this.expirationTime = frame.ttl + Date.now();
        this.availableLease = frame.requestCount;
        while (this.availableLease > 0 && this.pendingRequests.length > 0) {
            const handler = this.pendingRequests.shift();
            this.availableLease--;
            this.multiplexer.createRequestStream(handler);
        }
    }
    requestLease(handler) {
        const availableLease = this.availableLease;
        if (availableLease > 0 && Date.now() < this.expirationTime) {
            this.availableLease = availableLease - 1;
            this.multiplexer.createRequestStream(handler);
            return;
        }
        if (this.pendingRequests.length >= this.maxPendingRequests) {
            handler.handleReject(new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED, "No available lease given"));
            return;
        }
        this.pendingRequests.push(handler);
    }
    cancelRequest(handler) {
        const index = this.pendingRequests.indexOf(handler);
        if (index > -1) {
            this.pendingRequests.splice(index, 1);
        }
    }
}
exports.LeaseHandler = LeaseHandler;
class DefaultStreamRequestHandler {
    constructor(rsocket, fragmentSize) {
        this.rsocket = rsocket;
        this.fragmentSize = fragmentSize;
    }
    handle(frame, stream) {
        switch (frame.type) {
            case Frames_1.FrameTypes.REQUEST_FNF:
                if (this.rsocket.fireAndForget) {
                    new RequestFnFStream_1.RequestFnfResponderStream(frame.streamId, stream, this.rsocket.fireAndForget.bind(this.rsocket), frame);
                }
                return;
            case Frames_1.FrameTypes.REQUEST_RESPONSE:
                if (this.rsocket.requestResponse) {
                    new RequestResponseStream_1.RequestResponseResponderStream(frame.streamId, stream, this.fragmentSize, this.rsocket.requestResponse.bind(this.rsocket), frame);
                    return;
                }
                this.rejectRequest(frame.streamId, stream);
                return;
            case Frames_1.FrameTypes.REQUEST_STREAM:
                if (this.rsocket.requestStream) {
                    new RequestStreamStream_1.RequestStreamResponderStream(frame.streamId, stream, this.fragmentSize, this.rsocket.requestStream.bind(this.rsocket), frame);
                    return;
                }
                this.rejectRequest(frame.streamId, stream);
                return;
            case Frames_1.FrameTypes.REQUEST_CHANNEL:
                if (this.rsocket.requestChannel) {
                    new RequestChannelStream_1.RequestChannelResponderStream(frame.streamId, stream, this.fragmentSize, this.rsocket.requestChannel.bind(this.rsocket), frame);
                    return;
                }
                this.rejectRequest(frame.streamId, stream);
                return;
        }
    }
    rejectRequest(streamId, stream) {
        stream.send({
            type: Frames_1.FrameTypes.ERROR,
            streamId,
            flags: Frames_1.Flags.NONE,
            code: Errors_1.ErrorCodes.REJECTED,
            message: "No available handler found",
        });
    }
    close() { }
}
exports.DefaultStreamRequestHandler = DefaultStreamRequestHandler;
class DefaultConnectionFrameHandler {
    constructor(connection, keepAliveHandler, keepAliveSender, leaseHandler, rsocket) {
        this.connection = connection;
        this.keepAliveHandler = keepAliveHandler;
        this.keepAliveSender = keepAliveSender;
        this.leaseHandler = leaseHandler;
        this.rsocket = rsocket;
    }
    handle(frame) {
        switch (frame.type) {
            case Frames_1.FrameTypes.KEEPALIVE:
                this.keepAliveHandler.handle(frame);
                return;
            case Frames_1.FrameTypes.LEASE:
                if (this.leaseHandler) {
                    this.leaseHandler.handle(frame);
                    return;
                }
                // TODO throw exception and close connection
                return;
            case Frames_1.FrameTypes.ERROR:
                // TODO: add code validation
                this.connection.close(new Errors_1.RSocketError(frame.code, frame.message));
                return;
            case Frames_1.FrameTypes.METADATA_PUSH:
                if (this.rsocket.metadataPush) {
                    // this.rsocket.metadataPush()
                }
                return;
            default:
                this.connection.multiplexerDemultiplexer.connectionOutbound.send({
                    type: Frames_1.FrameTypes.ERROR,
                    streamId: 0,
                    flags: Frames_1.Flags.NONE,
                    message: "Received unknown frame type",
                    code: Errors_1.ErrorCodes.CONNECTION_ERROR,
                });
            // TODO: throw an exception and close connection
        }
    }
    pause() {
        var _a;
        this.keepAliveHandler.pause();
        (_a = this.keepAliveSender) === null || _a === void 0 ? void 0 : _a.pause();
    }
    resume() {
        var _a;
        this.keepAliveHandler.start();
        (_a = this.keepAliveSender) === null || _a === void 0 ? void 0 : _a.start();
    }
    close(error) {
        var _a;
        this.keepAliveHandler.close();
        (_a = this.rsocket.close) === null || _a === void 0 ? void 0 : _a.call(this.rsocket, error);
    }
}
exports.DefaultConnectionFrameHandler = DefaultConnectionFrameHandler;
var KeepAliveHandlerStates;
(function (KeepAliveHandlerStates) {
    KeepAliveHandlerStates[KeepAliveHandlerStates["Paused"] = 0] = "Paused";
    KeepAliveHandlerStates[KeepAliveHandlerStates["Running"] = 1] = "Running";
    KeepAliveHandlerStates[KeepAliveHandlerStates["Closed"] = 2] = "Closed";
})(KeepAliveHandlerStates || (KeepAliveHandlerStates = {}));
class KeepAliveHandler {
    constructor(connection, keepAliveTimeoutDuration) {
        this.connection = connection;
        this.keepAliveTimeoutDuration = keepAliveTimeoutDuration;
        this.state = KeepAliveHandlerStates.Paused;
        this.outbound = connection.multiplexerDemultiplexer.connectionOutbound;
    }
    handle(frame) {
        this.keepAliveLastReceivedMillis = Date.now();
        if (Frames_1.Flags.hasRespond(frame.flags)) {
            this.outbound.send({
                type: Frames_1.FrameTypes.KEEPALIVE,
                streamId: 0,
                data: frame.data,
                flags: frame.flags ^ Frames_1.Flags.RESPOND,
                lastReceivedPosition: 0,
            });
        }
    }
    start() {
        if (this.state !== KeepAliveHandlerStates.Paused) {
            return;
        }
        this.keepAliveLastReceivedMillis = Date.now();
        this.state = KeepAliveHandlerStates.Running;
        this.activeTimeout = setTimeout(this.timeoutCheck.bind(this), this.keepAliveTimeoutDuration);
    }
    pause() {
        if (this.state !== KeepAliveHandlerStates.Running) {
            return;
        }
        this.state = KeepAliveHandlerStates.Paused;
        clearTimeout(this.activeTimeout);
    }
    close() {
        this.state = KeepAliveHandlerStates.Closed;
        clearTimeout(this.activeTimeout);
    }
    timeoutCheck() {
        const now = Date.now();
        const noKeepAliveDuration = now - this.keepAliveLastReceivedMillis;
        if (noKeepAliveDuration >= this.keepAliveTimeoutDuration) {
            this.connection.close(new Error(`No keep-alive acks for ${this.keepAliveTimeoutDuration} millis`));
        }
        else {
            this.activeTimeout = setTimeout(this.timeoutCheck.bind(this), Math.max(100, this.keepAliveTimeoutDuration - noKeepAliveDuration));
        }
    }
}
exports.KeepAliveHandler = KeepAliveHandler;
var KeepAliveSenderStates;
(function (KeepAliveSenderStates) {
    KeepAliveSenderStates[KeepAliveSenderStates["Paused"] = 0] = "Paused";
    KeepAliveSenderStates[KeepAliveSenderStates["Running"] = 1] = "Running";
    KeepAliveSenderStates[KeepAliveSenderStates["Closed"] = 2] = "Closed";
})(KeepAliveSenderStates || (KeepAliveSenderStates = {}));
class KeepAliveSender {
    constructor(outbound, keepAlivePeriodDuration) {
        this.outbound = outbound;
        this.keepAlivePeriodDuration = keepAlivePeriodDuration;
        this.state = KeepAliveSenderStates.Paused;
    }
    sendKeepAlive() {
        this.outbound.send({
            type: Frames_1.FrameTypes.KEEPALIVE,
            streamId: 0,
            data: undefined,
            flags: Frames_1.Flags.RESPOND,
            lastReceivedPosition: 0,
        });
    }
    start() {
        if (this.state !== KeepAliveSenderStates.Paused) {
            return;
        }
        this.state = KeepAliveSenderStates.Running;
        this.activeInterval = setInterval(this.sendKeepAlive.bind(this), this.keepAlivePeriodDuration);
    }
    pause() {
        if (this.state !== KeepAliveSenderStates.Running) {
            return;
        }
        this.state = KeepAliveSenderStates.Paused;
        clearInterval(this.activeInterval);
    }
    close() {
        this.state = KeepAliveSenderStates.Closed;
        clearInterval(this.activeInterval);
    }
}
exports.KeepAliveSender = KeepAliveSender;
//# sourceMappingURL=RSocketSupport.js.map